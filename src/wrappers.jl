"""
This function is a generic implementation of oversampling methods that apply oversampling
logic independently to each class. 

# Arguments
- `X::AbstractMatrix`: A matrix or table where each row is an observation of floats
- `y::AbstractVector`: An abstract vector of class labels
- `oversample_per_class`: A function that takes a matrix of observations, a number
    of new observations to generate, and possibly other keyword arguments and 
    returns a matrix where each row is a new observation generated by the oversampling method
$DOC_RATIOS_ARGUMENT
- `kwargs`: Keyword arguments to pass to `oversample_per_class`

# Returns
- `Xover`: A matrix that includes the original observations and the 
    new observations generated by the oversampling method for each class.
- `yover`: An abstract vector of class labels that includes the original labels and the 
    new labels generated by the oversampling method for each class.
"""
function generic_oversample(
    X::AbstractMatrix{<:Real},
    y::AbstractVector,
    oversample_per_class,
    args...;
    ratios = nothing,
    kwargs...,
)
    X = transpose(X)
    # Get maps from labels to indices and the needed counts
    label_inds = group_inds(y)
    extra_counts = get_class_counts(y, ratios)
    # Apply oversample per class on each set of points belonging to the same class
    for (label, inds) in label_inds
        X_label = @view X[:, inds]
        n = extra_counts[label]
        n == 0 && continue
        Xnew = oversample_per_class(X_label, n, args...; kwargs...)
        ynew = fill(label, size(Xnew, 2))
        X = hcat(X, Xnew)
        y = vcat(y, ynew)
    end
    Xover = transpose(X)
    yover = y
    return Xover, yover
end

"""
Takes a table and returns a matrix and the column names of the table.

# Arguments
- `X::AbstractMatrix`: A matrix or table where each row is an observation of floats

# Returns
- `X::AbstractMatrix`: A matrix where each row is an observation of floats
- `names::AbstractVector`: A vector of column names
"""
const ERR_TABLE_TYPE(t) = "Error: expected a table or matrix but got a data of type $t."
function matrixify(X)
    Tables.istable(X) || throw(ERR_TABLE_TYPE(typeof(X)))
    if Tables.columnaccess(X)
        columns = Tables.columns(X)
        names = Tables.columnnames(columns)
        X = Tables.matrix(columns)
    else
        iter = iterate(Tables.rows(X))
        names = iter === nothing ? () : Tables.columnnames(first(iter))
        X = Tables.matrix(X)
    end
    return X, names
end

"""
Takes a function that takes X, y and keyword arguments but only works with abstract matrices 
and generalizes it to work with tables. To do this, it converts the table to a matrix, 
applies the function, then converts the matrix back to a table.

# Arguments
- `matrix_func::Function`: A function that takes a matrix of observations and a vector of labels 
    and returns a matrix of oversampled observations and a vector of oversampled labels
- `X::AbstractMatrix`: A table where each row is an observation of floats
- `y::AbstractVector`: An abstract vector of class labels

# Returns
- `Xover`: A table of the same type of X if possible (else a columntable) that 
    includes the original observations and the new observations generated by the 
    oversampling method.
- `yover`: An abstract vector of class labels that includes the original labels and 
    the new labels generated by the oversampling method.
"""
function tablify(
    matrix_func::Function,
    X,
    y::AbstractVector;
    materialize::Bool = true,
    kwargs...,
)
    Xm, names = matrixify(X)

    Xover, yover = matrix_func(Xm, y; kwargs...)
    Xover = Tables.table(Xover; header = names)

    # also maintain a way to convert it back to a table
    if materialize
        to_table = Tables.materializer(X)
        Xover = to_table(Xover)
    end
    return Xover, yover
end


"""
Overloads `tablify` to work with inputs where the label is one of the table columns.
"""
function tablify(matrix_func::Function, Xy, y_ind::Int; materialize::Bool = true, kwargs...)
    Xym, names = matrixify(Xy)

    # before proceeding as usual, split the matrix into X and y and merge them back after
    Xm = @view Xym[:, 1:end.!=y_ind]
    y = @view Xym[:, y_ind]
    Xover, yover = matrix_func(Xm, y; kwargs...)
    Xyover = hcat(Xover[:, 1:y_ind-1], yover, Xover[:, y_ind:end])
    Xyover = Tables.table(Xyover; header = names)

    # also maintain a way to convert it back to a table
    if materialize
        to_table = Tables.materializer(Xy)
        Xyover = to_table(Xyover)
    end

    return Xyover
end
# materialize => try_perserve_type (will think again)



function revert_oversampling(Xyover, length)
    Xy = Tables.subset(Xyover, 1:length)
    return Xy
end
