"""
This function is a generic implementation of oversampling methods that apply oversampling
logic independently to each class. 

# Arguments
- `X::AbstractMatrix`: A matrix or table where each row is an observation of floats
- `y::AbstractVector`: An abstract vector of class labels
- `oversample_per_class`: A function that takes a matrix of observations, a number
    of new observations to generate, and possibly other keyword arguments and 
    returns a matrix where each row is a new observation generated by the oversampling method
    - `ratios`: A parameter that controls the amount of oversampling to be done for each class.
    - Can be a dictionary mapping each class to the ratio of the needed number of observations for that class to the initial number of observations of the majority class.
    - Can be nothing and in this case each class will be oversampled to the size of the majority class.
    - Can be a float and in this case each class will be oversampled to the size of the majority class times the float.
- `kwargs`: Keyword arguments to pass to `oversample_per_class`

# Returns
- `Xover`: A matrix that includes the original observations and the 
    new observations generated by the oversampling method for each class.
- `yover`: An abstract vector of class labels that includes the original labels and the 
    new labels generated by the oversampling method for each class.
"""
function generic_oversample(
    X::AbstractMatrix{<:AbstractFloat}, y::AbstractVector, oversample_per_class; 
    ratios=nothing, kwargs...
)
    # Get maps from labels to indices and the needed counts
    label_inds = group_inds(y)
    extra_counts = get_class_counts(y, ratios)
    # Apply oversample per class on each set of points belonging to the same class
    for (label, inds) in label_inds
        X_label = @view X[inds, :]
        n = extra_counts[label]
        n == 0 && continue
        Xnew = oversample_per_class(X_label, n; kwargs...)
        ynew = fill(label, size(Xnew, 1))
        X = vcat(X, Xnew)
        y = vcat(y, ynew)
    end
    Xover = X
    yover = y
    return Xover, yover
end



"""
Takes a function that takes X, y and keyword arguments but only works with abstract matrices 
and generalizes it to work with tables. To do this, it converts the table to a matrix, 
applies the function, then converts the matrix back to a table.

# Arguments
- `matrix_func::Function`: A function that takes a matrix of observations and a vector of labels 
    and returns a matrix of oversampled observations and a vector of oversampled labels
- `X::AbstractMatrix`: A table where each row is an observation of floats
- `y::AbstractVector`: An abstract vector of class labels

# Returns
- `Xover`: A matrix table that includes the original observations and 
    the new observations generated by the oversampling method.
- `yover`: An abstract vector of class labels that includes the original labels and 
    the new labels generated by the oversampling method.
"""
function tablify(matrix_func::Function, X, y:: AbstractVector; kwargs...)
    # if its a table then convert it to a matrix then proceed as usual
    if Tables.istable(X)
        Xm = Tables.matrix(X)
        Xover, yover = matrix_func(Xm, y; kwargs...)
        # convert the resulting matrix into a matrix table using the column names of the original table
        header = Tables.columnnames(X)
        if length(header) == size(Xm, 2)
            return Tables.table(Xover; header=header), yover
        else
            return Tables.table(Xover), yover
        end
    # if not then it must be an unsupported type
    else
        T = typeof(X)
        msg = "Expected a Table or matrix. Got data of type $T."
        error(ArgumentError(msg))
    end
end




"""
Given a categorical array of discrete labels and a dictionary of ratios, return a dictionary
of the number of extra samples needed for each class to achieve the given ratio 
relative to the majority class.

# Arguments
- `y::AbstractVector`: An abstract vector of class labels
- `ratios`: A parameter that controls the amount of oversampling to be done for each class.
    - Can be a dictionary mapping each class to the ratio of the needed number of observations for that class to the initial number of observations of the majority class.
    - Can be nothing and in this case each class will be oversampled to the size of the majority class.
    - Can be a float and in this case each class will be oversampled to the size of the majority class times the float.

# Returns
- `Dict`: A dictionary mapping each class to the number of extra samples needed for
    that class to achieve the given ratio relative to the majority class.
"""
const ERR_MISSING_CLASS(c) = "Error: found class $c in y that is not in ratios."
const ERR_INVALID_RATIO(c) = "Error: ratio for class $c must be greater than 0."
const WRN_UNDERSAMPLE(new_ratio, label, less_counts, old_ratio) =  "ratio $new_ratio for class $label implies that the class \
                                                                    should have $less_counts less samples because it is already $old_ratio \
                                                                    of the majority class but SMOTE cannot undersample.
                                                                    Will skip oversampling for this class."
# Method for handling ratios as a dictionary
function get_class_counts(y::AbstractVector, ratios::Dict{T, <:AbstractFloat}) where T 
    label_counts = group_lengths(y)
    majority_count = maximum(values(label_counts))
    extra_counts = Dict{T, Int}()

    # each class needs to be the size specified in `ratios`
    for (label, count) in label_counts
        (label in keys(ratios)) || throw(ERR_MISSING_CLASS(label))
        ratios[label] > 0 || throw(ERR_INVALID_RATIO(label)) 
        extra_counts[label] = calculate_extra_counts(ratios[label], majority_count, count, label)
    end
    return extra_counts
end

# Method for handling ratios as AbstractFloat
function get_class_counts(y::AbstractVector{T}, ratio::AbstractFloat) where T
    label_counts = group_lengths(y)
    majority_count = maximum(values(label_counts))
    extra_counts = Dict{T, Int}()

    # each class needs to be the size specified in `ratio`
    for (label, count) in label_counts
        extra_counts[label] = calculate_extra_counts(ratio, majority_count, count, label)
    end

    return extra_counts
end

# Default method for when ratios is nothing
function get_class_counts(y::AbstractVector)
    get_class_counts(y, 1.0)
end

"""
Helper function for calculating the number of extra samples needed for a class given a ratio, its count and majoiry count.
"""
function calculate_extra_counts(ratio::AbstractFloat, majority_count::Integer, label_count::Integer, label)
    extra_count = Int(round(ratio * majority_count)) - label_count
    if extra_count < 0
        old_ratio = label_count / majority_count
        new_ratio = ratio
        less_counts = extra_count
        @warn WRN_UNDERSAMPLE(new_ratio, label, less_counts, old_ratio)
        extra_count = 0
    end
    return extra_count
end


randrows(rng::AbstractRNG, X) = X[rand(rng, 1:size(X, 1)), :]
randrows(rng::AbstractRNG, X, n) = X[rand(rng, 1:size(X, 1), n), :]
rng_handler(rng::Integer) = StableRNG(rng)
rng_handler(rng::AbstractRNG) = rng


"""
Return a dictionary mapping each unique value in an abstract vector to the indices of the array
where that value occurs.
"""
function group_inds(categorical_array::AbstractVector{T}) where T   
    result = LittleDict{T, AbstractVector{Int}}()
    freeze(result)
    for (i, v) in enumerate(categorical_array)
        if !haskey(result, v)
            result[v] = []
        end
        push!(result[v], i)
    end
    return result
end


"""
Return a dictionary mapping each unique value in an abstract vector to the number of times that value occurs.
"""
function group_lengths(categorical_array::AbstractVector{T}) where T   
    result = LittleDict{T, Int}()
    freeze(result)
    for v in categorical_array
        if !haskey(result, v)
            result[v] = 0
        end
        result[v] += 1
    end
    return result
end
