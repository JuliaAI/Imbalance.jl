"""
This function is a generic implementation of oversampling. 
It takes a function that oversamples a set of points belonging to the same class and 
applies it to each set of points belonging to the same class in the given 
observations matrix `X` and labels vector `y`.

# Arguments
- `X::AbstractMatrix`: A matrix or table where each row is an observation of floats
- `y::AbstractVector`: A categorical vector of labels
- `oversample_per_class`: A function that takes a matrix of observations and a number
    of new observations to generate and returns a matrix where each column is a 
    new observation generated by the oversampling method
- `ratios`: A dictionary mapping each class to the ratio of the needed number of observations 
    of that class to the current number of observations of the majority class. 
    If nothing, then each class will be oversampled to the size of the majority class and 
    if float then each class will be oversampled to the size of the majority class times 
    the float.
- `kwargs`: Keyword arguments to pass to `oversample_per_class`

# Returns
- `Xover`: A matrix or matrix table that includes oversampled observations.
- `yover`: A categorical vector of labels that includes oversampled labels.
"""
function generic_oversample(
    X::AbstractMatrix{<:AbstractFloat}, y, oversample_per_class; 
    ratios=nothing, kwargs...
)
    # Get maps from labels to indices and the needed counts
    label_inds = group_inds(y)
    extra_counts = get_class_counts(y, ratios)
    # Apply oversample per class on each set of points belonging to the same class
    for (label, inds) in label_inds
        X_label = @view X[inds, :]
        n = extra_counts[label]
        n == 0 && continue
        Xnew = oversample_per_class(X_label, n; kwargs...)
        ynew = fill(label, size(Xnew, 1))
        X = vcat(X, Xnew)
        y = vcat(y, ynew)
    end
    Xover = X
    yover = y
    return Xover, yover
end



"""
Takes a function that takes X, y and key-word argument but only works with abstract matrices 
and generalizes it to work with tables. To do this, it converts the table to a matrix, 
applies the function, then converts the matrix back to a table.

# Arguments
- `func::Function`: A function that takes a matrix of observations and a vector of labels 
    and returns a matrix of oversampled observations and a vector of oversampled labels
- `X::AbstractMatrix`: A  table where each row is an observation of floats
- `y::AbstractVector`: A categorical vector of labels

# Returns
- `Xover`: A matrix table that includes oversampled observations.
- `yover`: A categorical vector of labels that includes oversampled labels.

"""
function tablify(func::Function, X, y; kwargs...)
    # if its a table then convert it to a matrix then proceed as usual
    if Tables.istable(X)
        Xm = Tables.matrix(X)
        Xover, yover = func(Xm, y; kwargs...)
        # convert the resulting matrix into a matrix table using the column names of the original table
        header = Tables.columnnames(X)
        if length(header) == size(Xm, 2)
            return Tables.table(Xover; header=header), yover
        else
            return Tables.table(Xover), yover
        end
    # if not then it must be an unsupported type
    else
        T = typeof(X)
        msg = "Expected a Table or matrix. Got data of type $T."
        error(ArgumentError(msg))
    end
end




"""
Given a categorical array of discrete labels and a dictionary of ratios, return a dictionary
of the number of extra samples needed for each class to achieve the given ratio 
relative to the majority class.

# Arguments
- `y::AbstractVector`: A categorical vector of labels
- `ratios`: A dictionary mapping each class to the ratio of the needed number of
    observations of that class to the current number of observations of the majority class. 
    If nothing, then each class will be oversampled to the size of the majority class and 
    if float then each class will be oversampled to the size of the majority class times 
    the float.

# Returns
- `Dict`: A dictionary mapping each class to the number of extra samples needed for
    that class to achieve the given ratio relative to the majority class.
"""
function get_class_counts(y, ratios=nothing)
    label_counts = group_lens(y)
    majority_count = maximum(values(label_counts))
    extra_counts = Dict()
    if isnothing(ratios)
        # each class needs to be the same size as the majority class
        for (label, count) in label_counts
            extra_counts[label] = majority_count - count
        end
    # else if its a dictionary
    elseif isa(ratios, Dict)
        # each class needs to be the size specified in `ratios`
        for (label, _) in label_counts
            if !(label in keys(ratios))
                msg = "ratios must contain a key for each class in y. \
                Could not find ratio for class $label"
                error(ArgumentError(msg))
            elseif ratios[label] < 0
                    msg = "ratio for any class must be greater than or equal to 0."
                    error(ArgumentError(msg))
            else
                extra_counts[label] = (Int(round(ratios[label] * majority_count))
                                    - label_counts[label])
                if extra_counts[label] < 0
                    old_ratio = label_counts[label] / majority_count
                    new_ratio = ratios[label]
                    less_counts = extra_counts[label] 
                    # produce warning
                    @warn "ratio $new_ratio for class $label implies that the class should have \
                    $less_counts less samples because it is already $old_ratio of the
                     majority class but SMOTE cannot undersample.
                     Will skip oversampling for this class."
                    extra_counts[label] = 0
                end
            end
        end
    # else if its a float
    elseif isa(ratios, AbstractFloat)
        # each class needs to be the size specified in `ratios`
        for (label, _) in label_counts
            extra_counts[label] = Int(round(ratios * majority_count)) - label_counts[label]
            if extra_counts[label] < 0
                old_ratio = label_counts[label] / majority_count
                new_ratio = ratios
                less_counts = extra_counts[label]
                # produce warning
                @warn "ratio $new_ratio for class $label implies that the class \
                should have $less_counts less samples because it is already $old_ratio \
                of the majority class but SMOTE cannot undersample.
                Will skip oversampling for this class."
                extra_counts[label] = 0
            end
        end
    else
        msg = "ratios must be a dictionary or a float."
        error(ArgumentError(msg))
    end
    return extra_counts
end


randrows(rng::AbstractRNG, X) = X[rand(rng, 1:size(X, 1)), :]
randrows(rng::AbstractRNG, X, n) = X[rand(rng, 1:size(X, 1), n), :]

function group_inds(categorical_array)
    result = Dict()
    for (i, v) in enumerate(categorical_array)
        if !haskey(result, v)
            result[v] = []
        end
        push!(result[v], i)
    end
    return result
end

function group_lens(categorical_array)
    result = Dict()
    for v in categorical_array
        if !haskey(result, v)
            result[v] = 0
        end
        result[v] += 1
    end
    return result
end
