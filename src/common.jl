"""
This function is a generic implementation of oversampling methods that apply oversampling
logic independently to each class. 

# Arguments
- `X::AbstractMatrix`: A matrix or table where each row is an observation of floats
- `y::AbstractVector`: An abstract vector of class labels
- `oversample_per_class`: A function that takes a matrix of observations, a number
    of new observations to generate, and possibly other keyword arguments and 
    returns a matrix where each row is a new observation generated by the oversampling method
$DOC_RATIOS_ARGUMENT
- `kwargs`: Keyword arguments to pass to `oversample_per_class`

# Returns
- `Xover`: A matrix that includes the original observations and the 
    new observations generated by the oversampling method for each class.
- `yover`: An abstract vector of class labels that includes the original labels and the 
    new labels generated by the oversampling method for each class.
"""
function generic_oversample(
    X::AbstractMatrix{<:AbstractFloat},
    y::AbstractVector,
    oversample_per_class,
    args...;
    ratios = nothing,
    kwargs...,
)
    X = transpose(X)
    # Get maps from labels to indices and the needed counts
    label_inds = group_inds(y)
    extra_counts = get_class_counts(y, ratios)
    # Apply oversample per class on each set of points belonging to the same class
    for (label, inds) in label_inds
        X_label = @view X[:, inds]
        n = extra_counts[label]
        n == 0 && continue
        Xnew = oversample_per_class(X_label, n, args...; kwargs...)
        ynew = fill(label, size(Xnew, 2))
        X = hcat(X, Xnew)
        y = vcat(y, ynew)
    end
    Xover = transpose(X)
    yover = y
    return Xover, yover
end



"""
Takes a function that takes X, y and keyword arguments but only works with abstract matrices 
and generalizes it to work with tables. To do this, it converts the table to a matrix, 
applies the function, then converts the matrix back to a table.

# Arguments
- `matrix_func::Function`: A function that takes a matrix of observations and a vector of labels 
    and returns a matrix of oversampled observations and a vector of oversampled labels
- `X::AbstractMatrix`: A table where each row is an observation of floats
- `y::AbstractVector`: An abstract vector of class labels

# Returns
- `Xover`: A table of the same type of X if possible (else a columntable) that 
    includes the original observations and the new observations generated by the 
    oversampling method.
- `yover`: An abstract vector of class labels that includes the original labels and 
    the new labels generated by the oversampling method.
"""
const ERR_TABLE_TYPE(t) = "Error: expected a table or matrix but got a data of type $t."
function tablify(matrix_func::Function, X, y::AbstractVector; kwargs...)
    Tables.istable(X) || throw(ERR_TABLE_TYPE(typeof(X)))
    # if its a table then convert it to a matrix then proceed as usual
    Xm = Tables.matrix(X)
    Xover, yover = matrix_func(Xm, y; kwargs...)
    # also maintain a way to convert it back to a table
    to_table = Tables.materializer(X)
    Xc = Tables.columns(X)
    header = Tables.columnnames(Xc)
    # if header is set as the default, we skip setting it
    if header != Tables.propertynames(Xc)
        return to_table(Tables.table(Xover; header = header)), yover
    else
        return to_table(Tables.table(Xover)), yover
    end
end
