"""
This files defines the `generic_oversample` function which is used by all the oversampling methods.
"""

"""
This function is a generic implementation of oversampling methods that apply some oversampling
logic to find the new data for each class then combining with old data to form the final dataset.

# Arguments
- `X`: A matrix or table where each row is an observation of real numbers
- `y`: An abstract vector of class labels
- `oversample_per_class`: A function that takes a matrix of observations, a number
    of new observations to generate, and possibly arguments and 
    returns a matrix where each row is a new observation generated by the oversampling method
$(COMMON_DOCS["RATIOS"])
- `args`: positional arguments  to pass to `oversample_per_class`
- `kwargs`: Keyword arguments to pass to `oversample_per_class`

# Returns
- `Xover`: A matrix that includes the original observations and the 
    new observations generated by the oversampling method for each class.
- `yover`: An abstract vector of class labels that includes the original labels and the 
    new labels generated by the oversampling method for each class.
"""
function generic_oversample(
    X::AbstractMatrix{<:Real},
    y::AbstractVector,
    oversample_per_class,
    args...;
    ratios = 1.0,
    kwargs...,
)
    # Transposing for performance (hcat) and as assumed by NearestNeighbors
    X = transpose(X)
    # Get maps from labels to indices and the needed counts
    label_inds = group_inds(y)
    extra_counts = get_class_counts(y, ratios)
    # Apply oversample per class on each set of points belonging to the same class
    p = Progress(length(label_inds))
    for (label, inds) in label_inds
        !(label in keys(extra_counts)) && continue
        # Get points belonging to class
        X_label = @view X[:, inds]
        # How many points does it need?
        n = extra_counts[label]
        n == 0 && continue
        # Generate the n needed new points
        Xnew = oversample_per_class(X_label, n, args...; kwargs...)
        # Generate the corresponding labels
        ynew = fill(label, size(Xnew, 2))
        X = hcat(X, Xnew)
        y = vcat(y, ynew)
        next!(p; showvalues = [(:class, label)])
    end
    Xover = transpose(X)
    yover = y
    return Xover, yover
end


"""
This function is a generic implementation of undersampling methods that apply some undersampling
    logic to find the new data for each class then combining them all to form the final dataset.
    
    # Arguments
    - `X`: A matrix or table where each row is an observation of real numbers
    - `y`: An abstract vector of class labels
    - `undersample_per_class`: A function that takes a matrix of observations, a number
        of observations to generate, and possibly other arguments and 
        returns a matrix where each row is a new observation generated by the undersampling method
    $(COMMON_DOCS["RATIOS-UNDERSAMPLE"])
    - `args`: positional arguments  to pass to `undersample_per_class`
    - `kwargs`: Keyword arguments to pass to `undersample_per_class`
    
    # Returns
    - `X_under`: A matrix that includes the the undersampled
        new observations generated by the undersampling method for each class.
    - `y_under`: An abstract vector of class labels corresponding to `X_under`
"""
function generic_undersample(
    X::AbstractMatrix{<:Real},
    y::AbstractVector,
    undersample_per_class,
    args...;
    ratios = 1.0,
    kwargs...,
)
    # Transposing for performance (hcat) and as assumed by NearestNeighbors
    X = transpose(X)
    # Get maps from labels to indices and the needed counts
    label_inds = group_inds(y)
    undersampled_counts = get_class_counts(y, ratios; reference="minority")
    num_feats = size(X, 1)
    # Declare X_under, y_under
    X_under = Matrix{Any}(undef, num_feats, 0)
    y_under = Vector{Any}(undef, 0)
    # Apply undersample per class on each set of points belonging to the same class
    p = Progress(length(label_inds))
    for (label, inds) in label_inds
        # Get points belonging to class
        X_label = @view X[:, inds]
        old_count = size(X_label, 2)
        # Skip if no ratio is given for it or if ratio is already satisfied
        n = get(undersampled_counts, label, "ϕ")
        if n == "ϕ" || n == old_count
            # class data is unchanged
            X_under = hcat(X_under, X_label)
            y_under = vcat(y_under, y[inds])
            continue
        end
        # Generate the n needed new points
        Xnew = undersample_per_class(X_label, n, args...; kwargs...)
        # Generate the corresponding labels
        ynew = fill(label, size(Xnew, 2))
        X_under = hcat(X_under, Xnew)
        y_under = vcat(y_under, ynew)
        next!(p; showvalues = [(:class, label)])
    end
    X_under = transpose(X_under)
    return X_under, y_under
end