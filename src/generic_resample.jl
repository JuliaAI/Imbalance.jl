"""
This files defines the `generic_oversample` function which is used by all the oversampling methods.
"""

"""
This function is a generic implementation of oversampling methods that apply some oversampling
    logic to find the new data for each class then combining with old data to form the final oversampled dataset.

# Arguments
- `X`: A matrix or table where each row is an observation of real numbers
- `y`: An abstract vector of class labels
- `oversample_per_class`: A function that takes a matrix of observations, a number
	of new observations to generate, and possibly arguments and 
	returns a matrix where each row is a new observation generated by the oversampling method
$(COMMON_DOCS["RATIOS"])
- `args`: positional arguments  to pass to `oversample_per_class`
- `kwargs`: Keyword arguments to pass to `oversample_per_class`

# Returns
- `Xover`: A matrix that includes the original observations and the 
	new observations generated by the oversampling method for each class.
- `yover`: An abstract vector of class labels that includes the original labels and the 
	new labels generated by the oversampling method for each class.
"""
function generic_oversample(
    X::AbstractMatrix{<:Union{Real, Missing}},
    y::AbstractVector,
    oversample_per_class,
    args...;
    ratios = 1.0,
    pass_inds::Bool = false,
    is_transposed::Bool = false,
    kwargs...,
)
    # Transposing for performance (hcat) and as assumed by NearestNeighbors
    is_transposed || (X = transpose(X))
    # Get maps from labels to indices and the needed counts
    label_inds = group_inds(y)
    extra_counts = get_class_counts(y, ratios)
    # Apply oversample per class on each set of points belonging to the same class
    p = Progress(length(label_inds))
    for (label, inds) in label_inds
        !(label in keys(extra_counts)) && continue
        # Get points belonging to class
        X_label = @view X[:, inds]
        # How many points does it need?
        n = extra_counts[label]
        n == 0 && continue
        # Generate the n needed new points
        Xnew =
            (pass_inds) ? oversample_per_class(X_label, n, inds, args...; kwargs...) :
            oversample_per_class(X_label, n, args...; kwargs...)
        # Generate the corresponding labels
        ynew = fill(label, size(Xnew, 2))
        X = hcat(X, Xnew)
        y = vcat(y, ynew)
        next!(p; showvalues = [(:class, label)])
    end
    Xover = transpose(X)
    yover = y
    return Xover, yover
end

"""
This function is a generic implementation of undersampling methods that apply some undersampling
	logic to find the new data for each class then combining them all to form the final dataset.
	
	# Arguments
	- `X`: A matrix or table where each row is an observation of real numbers
	- `y`: An abstract vector of class labels
	- `undersample_per_class`: A function that takes a matrix of observations, a number
		of observations to generate, and possibly other arguments and 
		returns a matrix where each row is a new observation generated by the undersampling method
    - `args`: positional arguments  to pass to `undersample_per_class`
	$(COMMON_DOCS["RATIOS-UNDERSAMPLE"])
    - `pass_inds`: Whether to pass the indices of each class to `undersample_per_class`
    - `is_transposed`: If true, does not transpose the given `X`
	- `kwargs`: Keyword arguments to pass to `undersample_per_class`
	
	# Returns
	- `X_under`: A matrix that includes the the undersampled
		new observations generated by the undersampling method for each class.
	- `y_under`: An abstract vector of class labels corresponding to `X_under`
"""
function generic_undersample(
    X::AbstractMatrix{<:Union{Real, Missing}},
    y::AbstractVector,
    undersample_per_class,
    args...;
    ratios = 1.0,
    pass_inds::Bool = false,
    is_transposed::Bool = false,
    kwargs...,
)
    # Transposing for performance (hcat) and as assumed by NearestNeighbors
    is_transposed || (X = transpose(X))
    # Get maps from labels to indices and the needed counts
    label_inds = group_inds(y)
    undersampled_counts = get_class_counts(y, ratios; reference = "minority")
    num_feats = size(X, 1)
    # Declare X_under, y_under
    X_under = Matrix{eltype(X)}(undef, num_feats, 0)
    y_under = Vector{eltype(y)}(undef, 0)
    # Apply undersample per class on each set of points belonging to the same class
    p = Progress(length(label_inds))
    for (label, inds) in label_inds
        # Get points belonging to class
        X_label = @view X[:, inds]
        old_count = size(X_label, 2)
        # Skip if no ratio is given for it or if ratio is already satisfied
        n = get(undersampled_counts, label, "ϕ")
        if n == "ϕ" || n == old_count
            # class data is unchanged
            X_under = hcat(X_under, X_label)
            y_under = vcat(y_under, y[inds])
            continue
        end
        # Generate the n needed new points
        Xnew =
            (pass_inds) ? undersample_per_class(X_label, n, inds, args...; kwargs...) :
            undersample_per_class(X_label, n, args...; kwargs...)
        # Generate the corresponding labels
        ynew = fill(label, size(Xnew, 2))
        X_under = hcat(X_under, Xnew)
        y_under = vcat(y_under, ynew)
        next!(p; showvalues = [(:class, label)])
    end
    X_under = transpose(X_under)
    return X_under, y_under
end

"""
Can be generically used with any cleaning method that outputs a filter to apply on points for each class.
It takes such boolean filter that designates which points should be kept and modifies it to keep more or less points.

# Arguments
- filter: boolean filter
- n: minimum number of points required to be kept for the class
- force_min_ratios: whether to force further random undersampling if the filter keeps more than `n` points
- rng: random number generator for random undersampling or random revival in case of excessive cleaning

# Returns  
- filter: modified boolean filter
"""
function filter_modifier(
    filter::AbstractVector{Bool},
    n,
    force_min_ratios::Bool = false,
    rng::AbstractRNG = default_rng(),
)
    num_keep = sum(filter)
    (num_keep == n) && return filter
    if num_keep < n
        # need to satisfy min_ratios (no excessive cleaning)
        filter_0 = @view filter[filter.==false]
        # revive some cleaned points
        n_further = n - num_keep
        filter_0[sample(rng, 1:length(filter_0), n_further, replace = false)] .= 1
    elseif num_keep > n && force_min_ratios
        filter_1 = @view filter[filter.==true]
        # need to further undersample
        n_further = num_keep - n
        filter_1[sample(rng, 1:length(filter_1), n_further, replace = false)] .= 0
    end
    return filter
end

"""
Given the data belonging to a class and a boolean filter vector, filter the data.
- `X`: A matrix where each column is an observation of floats belonging to the same class
-`n`: Minimum number of observations to keep
- `inds`: Indices of the observations belonging the class 
- `filter`: A boolean filter vector for all the points
- `force_min_ratios`: If true, further random undersampling may be applied to satisfy keeping exactly `n`
- `rng`: Random number generator for random undersampling (or random revival of cleaned points)
"""
function generic_clean_per_class(
    X::AbstractMatrix{<:Real},
    n::Integer,
    inds::AbstractVector{<:Integer},
    filter::AbstractVector{Bool};
    force_min_ratios::Bool = false,
    rng::AbstractRNG = default_rng(),
)
    filter_per_class = filter[inds]
    filter_per_class = filter_modifier(filter_per_class, n, force_min_ratios, rng)
    Xnew = X[:, filter_per_class]
    return Xnew
end
