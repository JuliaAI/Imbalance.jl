# Disclaimer: This implementation is inspired by that of Resample.jl


"""
Choose a random point from the given observations matrix `X` and generate a new point that 
randomly lies in the line joining the random point and randomly one of its k-nearest neighbors. 

# Arguments
- `X::AbstractMatrix`: A matrix where each row is an observation
- `tree`: A k-d tree representation of the observations matrix X
- `k::Int`: Number of nearest neighbors to consider
- `rng::AbstractRNG`: Random number generator

# Returns
- `AbstractVector`: A new observation generated by SMOTE
"""
function generate_new_smote_point(
    X::AbstractMatrix{<:AbstractFloat},
    tree;
    k::Int,
    rng::AbstractRNG,
)
    x_rand = randcols(rng, X)
    x_randneigh = get_random_neighbor(X, tree, x_rand; k, rng)
    x_new = get_collinear_point(x_rand , x_randneigh; rng)
    return x_new
end


"""
Assuming that all the observations in the observation matrix X belong to the same class,
use SMOTE to generate `n` new observations for that class.

# Arguments
- `X::AbstractMatrix`: A matrix where each row is an observation
- `n::Int`: Number of new observations to generate
- `k::Int`: Number of nearest neighbors to consider. Must be less than the 
    number of observations in `X`
- `rng::AbstractRNG`: Random number generator

# Returns
- `AbstractMatrix`: A matrix where each row is a new observation generated by SMOTE
"""
function smote_per_class(
    X::AbstractMatrix{<:AbstractFloat},
    n::Int;
    k::Int = 5,
    rng::AbstractRNG = default_rng(),
)
    size(X, 2) == 1 && (warn("class with a single observation will be ignored"); return X)
    k = (k > 0) ? min(k, size(X, 1) - 1) : 1
    tree = KDTree(X)
    return hcat([generate_new_smote_point(X, tree; k, rng) for i = 1:n]...)
end


"""
    function smote(
        X, y::AbstractVector;
        k::Int=5, ratios=nothing, rng::Union{AbstractRNG, Integer}=default_rng()
    )

Oversample a dataset given by a matrix or table of observations `X` and an abstract vector of labels y using SMOTE.

$DOC_MAIN_ARGUMENTS
- `k::Int`: Number of nearest neighbors to consider in the SMOTE algorithm. 
    Should be within the range `[1, size(X, 1) - 1]` else set to the nearest of these two values.
$DOC_RATIOS_ARGUMENT
$DOC_RNG_ARGUMENT
$DOC_RETURNS
"""
function smote(
    X::AbstractMatrix{<:AbstractFloat},
    y::AbstractVector;
    k::Int = 5,
    ratios = nothing,
    rng::Union{AbstractRNG,Integer} = default_rng(),
)
    rng = rng_handler(rng)
    Xover, yover = generic_oversample(X, y, smote_per_class; ratios, k, rng)
    return Xover, yover
end


function smote(
    X,
    y::AbstractVector;
    k::Int = 5,
    ratios = nothing,
    rng::Union{AbstractRNG,Integer} = default_rng(),
)
    Xover, yover = tablify(smote, X, y; k, ratios, rng)
    return Xover, yover
end
