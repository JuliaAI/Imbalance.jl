# Disclaimer: This implementation is inspired by that of Resample.jl

"""
Genrate a new random observation that lies in the line joining the two observations `x₁` and `x₂`

# Arguments
- `x₁::AbstractVector`: First observation
- `x₂::AbstractVector`: Second observation
- `rng::AbstractRNG`: Random number generator

# Returns
- `AbstractVector`: New observation `x`` that satisfies `x = (x₂ - x₁) * r + x₁` where `r`` is a random number between `0` and `1`
"""
function get_midway_point(x₁::AbstractVector, x₂ ::AbstractVector, rng)
    r = rand(rng)
    return (1 - r) .* x₁ .+ r .* x₂ 
    # Equivalent to (x₂  .- x₁ ) .* r .+ x₁  but avoids allocating a new vector
end


"""
Randomly return one of the k-nearest neighbor of a given observation `x` from an observations matrix `X` represented by a k-d tree

# Arguments
- `X::AbstractMatrix`: A matrix where each column is an observation
- `tree`: A k-d tree representation of the observations matrix `X`
- `x::AbstractVector`: An observation given as a column vector
- `k::Int`: Number of nearest neighbors to consider
- `rng::AbstractRNG`: Random number generator

# Returns
- `AbstractVector`: A random observation from the k-nearest neighbors of x
"""
function get_random_neighbor(X::AbstractMatrix{<:AbstractFloat}, tree, x::AbstractVector, k, rng)
    inds, _ = knn(tree, x, k + 1, true)
    # We need to deal with that the first neighbor is the point itself; hence, the k+1 and the 2:end
    random_neighbor_index = randobs(rng, inds[2:end])
    random_neighbor = getobs(X, random_neighbor_index)
    return random_neighbor
end

"""
Choose a random point from the given observations matrix `X` and apply SMOTE logic on it to generate a new point. 
SMOTE logic implictly assumes that all the observations belong to the same class.

# Arguments
- `X::AbstractMatrix`: A matrix where each column is an observation
- `tree`: A k-d tree representation of the observations matrix X
- `k::Int`: Number of nearest neighbors to consider
- `rng::AbstractRNG`: Random number generator

# Returns
- `AbstractVector`: A new observation generated by SMOTE

"""
function generate_new_smote_point(X::AbstractMatrix{<:AbstractFloat}, tree, k, rng::AbstractRNG)
    random_point = randobs(rng, X)
    random_neighbor = get_random_neighbor(X, tree, random_point, k, rng)
    new_point = get_midway_point(random_point, random_neighbor, rng)
    return new_point
end


"""
Generate n new observations using SMOTE and assuming that all the observations in the observation matrix X belong to the same class.

# Arguments
- `X::AbstractMatrix`: A matrix where each column is an observation
- `n::Int`: Number of new observations to generate
- `k::Int`: Number of nearest neighbors to consider. Must be less than the number of observations in X
- `rng::AbstractRNG`: Random number generator

# Returns
- `AbstractMatrix`: A matrix where each column is a new observation generated by SMOTE
"""
function smote_per_class(X::AbstractMatrix{<:AbstractFloat}, n::Int; k::Int=5, rng::AbstractRNG=default_rng())
    k = min(k, numobs(X) - 1)
    tree = KDTree(X)
    return hcat([generate_new_smote_point(X, tree, k, rng) for i in 1:n]...)    
end


"""
    SMOTE(X::AbstractMatrix{<:AbstractFloat}, y; k::Int=5, ratios=nothing, rng::AbstractRNG=default_rng())
    SMOTE(X, y; k::Int=5, ratios=nothing, rng::AbstractRNG=default_rng()

Oversample a dataset given by a matrix of observations X and a categorical vector of labels y using SMOTE.

# Arguments
- `X`: A matrix or table where each row is an observation of floats
- `y::AbstractVector`: A categorical vector of labels
- `k::Int`: Number of nearest neighbors to consider
- `ratios`: A dictionary mapping each class to the ratio of the needed number of observations of that class to
 the current number of observations of the majority class. If nothing, then each class will be oversampled to the size
  of the majority class and if float then each class will be oversampled to the size of the majority class times the float.
- `rng::AbstractRNG`: Random number generator

# Returns
- `Xover`: A matrix or matrix table that includes oversampled observations.
- `yover`: A categorical vector of labels that includes oversampled labels.
"""
function SMOTE(X::AbstractMatrix{<:AbstractFloat}, y; k::Int=5, ratios=nothing, rng::AbstractRNG=default_rng())
    # Both MLUtils and NearestNeighbors assume observations are columns
    X = transpose(X)
    # Get maps from labels to indices and the needed counts
    label_inds = group_indices(y)
    extra_counts = get_class_counts(y, ratios)
    # Apply smote per class on each set of points belonging to the same class
    for (label, inds) in label_inds
        X_label = getobs(X, inds)
        n = extra_counts[label]
        n == 0 && continue
        Xnew = smote_per_class(X_label, n; k, rng)
        ynew = fill(label, size(Xnew, 2))
        X = hcat(X, Xnew)
        y = vcat(y, ynew)        
    end
    Xover = transpose(X)
    yover = y
    return Xover, yover
end

function SMOTE(X, y; k::Int=5, ratios=nothing, rng::AbstractRNG=default_rng())
    # if its a table then convert it to a matrix then proceed as usual
    if Tables.istable(X)
        Xm = Tables.matrix(X)
        Xover, yover = SMOTE(Xm, y; k, ratios, rng)
        # convert the resulting matrix into a matrix table using the column names of the original table
        header = Tables.columnnames(X)
        if length(header) == numobs(Xm)
            return Tables.table(Xover; header=header), yover
        else
            return Tables.table(Xover), yover
        end
    # if not then it must be an unsupported type 
    else
        T = typeof(X)
        msg = "Expected tabular data or matrix. Got data of type $T."
        error(ArgumentError(msg))
    end
end

