"""
This files defines the `generic_oversample` function which is used by all the oversampling methods.
"""

"""
This function is a generic implementation of oversampling methods that apply oversampling
logic independently to each class.

# Arguments
- `X::AbstractMatrix`: A matrix or table where each row is an observation of floats
- `y::AbstractVector`: An abstract vector of class labels
- `oversample_per_class`: A function that takes a matrix of observations, a number
    of new observations to generate, and possibly other keyword arguments and 
    returns a matrix where each row is a new observation generated by the oversampling method
$(COMMON_DOCS["RATIOS"])
- `kwargs`: Keyword arguments to pass to `oversample_per_class`

# Returns
- `Xover`: A matrix that includes the original observations and the 
    new observations generated by the oversampling method for each class.
- `yover`: An abstract vector of class labels that includes the original labels and the 
    new labels generated by the oversampling method for each class.
"""
function generic_oversample(
    X::AbstractMatrix{<:Real},
    y::AbstractVector,
    oversample_per_class,
    args...;
    ratios = 1.0,
    kwargs...,
)
    # Transposing for performance (hcat) and as assumed by NearestNeighbors
    X = transpose(X)
    # Get maps from labels to indices and the needed counts
    label_inds = group_inds(y)
    extra_counts = get_class_counts(y, ratios)
    # Apply oversample per class on each set of points belonging to the same class
    p = Progress(length(label_inds))
    for (label, inds) in label_inds
        !(label in keys(extra_counts)) && continue
        # Get points belonging to class
        X_label = @view X[:, inds]
        # How many points does it need?
        n = extra_counts[label]
        n == 0 && continue
        # Generate the n needed new points
        Xnew = oversample_per_class(X_label, n, args...; kwargs...)
        # Generate the corresponding labels
        ynew = fill(label, size(Xnew, 2))
        X = hcat(X, Xnew)
        y = vcat(y, ynew)
        next!(p; showvalues = [(:class, label)])
    end
    Xover = transpose(X)
    yover = y
    return Xover, yover
end
